/*************************************************************
	Практическое занятие №3. Встроенные массивы.
							Динамическое выделение памяти.
							Простейшие алгоритмы сортировки и поиска.
							Сложные указатели.
							Ссылки.
*************************************************************/

//#include <cstdlib>
#include <ctime>
#include <iostream>
#include <string>
#define	  stop __asm nop

enum print_format
{
	WITHOUT_SPACES,
	WITH_SPACES,
	WITH_SPACES_AND_QUOTAS
};

char get_symbol() {
	return (std::rand() % 2) ? '_' : '*';
}

int get_random_number() {
	int n = 0;
	while (!n)	n = std::rand() % 30;
	return n;
}

bool binary_search_r(int* p, int e, size_t end, size_t start = 0)
{
	if (e < *(p + start) || e > *(p + end)) return false;
	if (start == end) return (e == *(p + start)) ? true : false;
	size_t m = start + (end - start) / 2;
	return (e <= *(p + m)) ? binary_search_r(p, e, m) : binary_search_r(p, e, end, (m + 1));
}

bool binary_search(int* p, int e, size_t end, size_t start = 0)
{
	if (e < *(p + start) || e > *(p + end)) return false;	
	while (start < end)
	{
		size_t m = start + (end - start) / 2;
		(e <= *(p + m)) ? end = m : start = m + 1 ;
		/*/
		if (e <= *(p + m)) 
		{
			end = m;
		}
		else
		{
			start = m + 1;
		}
		*/
	}
	return (e == *(p + start)) ? true : false;

}

void selection_sort(int* p, size_t n) {

	for (size_t i = 0; i < (n - 1); i++)
	{
		int offset = i;
		int min = i;
		for (size_t j = i; j < n; j++) if (*(p + min) > *(p + j)) min = j;
		int t = *(p + offset);
		*(p + offset) = *(p + min);
		*(p + min) = t;
	}
}

void print_char_array(char* c, size_t elements, size_t elements_per_row, print_format pf = WITHOUT_SPACES)
{
	while (elements)
	{
		if (!(elements % elements_per_row)) std::cout << std::endl;
		switch (pf)
		{
		case WITHOUT_SPACES:
			std::cout << *c;
			break;
		case WITH_SPACES:
			std::cout << *c << " ";
			break;
		case WITH_SPACES_AND_QUOTAS:
			std::cout << "'" << *c << "' ";
			break;
		}
		c++;
		elements--;
	}
	std::cout << std::endl;
}


int main()
{

///////////////////////////////////////////////////////////////
//			Встроенные массивы                               //
///////////////////////////////////////////////////////////////
/*
	//Задание 1. Объявите трехмерный N*M*K массив и сформируйте указанные
	//значения элементов следующим образом:
	//а) проинициализируйте массив при объявлении
	//б)* объявите неинициализированный массив и присвойте значения элементам
	//	с помощью кода
	//					 |--------|		
	//				   / |3  3  3 |		
	//    			 |---------|3 |
    //			   / | 2  2  2 |3 |
	//			  |---------|2 |__|
	//			  | 1  1  1 |2 | /
	//			  | 1  1  1 |__| 
	//			  | 1  1  1 | /
	//			  |_________|
	//Средствами отладчика проверьте правильность Вашего решения.

	//в) найдите сумму элементов массива. Подумайте, как это сделать эффективно.
	 
	//г) проинициализируйте массив при определении:
	//					 |--------|		
	//				   / |3  0  0 |		
	//    			 |---------|0 |
    //			   / | 2  0  0 |0 |
	//			  |---------|0 |__|
	//			  | 1  0  0 |0 | /
	//			  | 0  0  0 |__| 
	//			  | 0  0  0 | /
	//			  |_________|
  


	//д)* Инициализация массивов строковыми литералами:
	//Объявите и проинициализируйте строковыми литералами два массива:
	//двухмерный массив и массив указателей. Поясните разницу в использовании
	//элементов таких массивов.
*/
/////////////////////////////////////////////////////////////////////
//Задание 2. а) Напишите фрагмент кода, который вводит N целых чисел с помощью
//потока ввода в объявленный Вами ВСТРОЕННЫЙ одномерный массив, каждый раз
//упорядочивая полученное значение по возрастанию



//б) Простой поиск.
//Модифицируйте предыдущее задание следующим образом:очередное значение
//вводится в массив только при условии, что там еще такого нет (то есть 
//дубли игнорируются

	/*
	const int iN = 7;
	int iarray[iN] = { 0 };
	size_t n = sizeof(iarray) / sizeof(iarray[0]);
	int* p = iarray;

	//for (size_t i = 0; i < n; i++, p++) *p = get_random_number();

	p = iarray;
	

	for (size_t i = 0; i < n; i++)
	{
		bool is_found;
		do
		{
			int e = 0;
			std::cout << "please input element [" << i << "] = ";
			std::cin >> e;
			
			is_found = binary_search(p, e, (n - 1));
			if (is_found) std::cout << "this element already exist" << std::endl;
			else
			{
				*p = e;
				selection_sort(p, n);
			}
		} while (is_found);
	}
	*/
	stop


	///////////////////////////////////////////////////////////////////////////
	//Задание 3*.С помощью данной заготовки напишите программу,
	//которая:
	//вводит строки с клавиатуры с помощью cin>>...
	//в объявленный Вами двухмерный ВСТРОЕННЫЙ массив 5*80 элементов типа char;
	//признаком конца ввода является символ * (то есть строка - "*") или
	//заполнение массива (больше свободных строк нет);
	//сортировка строк в алфавитном порядке. Пояснение: крайне
	//не рекомендуется для сортировки сложных объектов физически
	//перемещать их в памяти. Намного эффективнее завести массив
	//указателей на соответствующие строки и перемещать только
	//указатели.

	//Подсказка: для лексиграфического сравнения строк пользуйтесь
	//функцией стандартной библиотеки strcmp(...), заголовочный файл <string>.


	//Определите необходимые значения как константы
	//STOP_STRING  -  "*"	//признак "прекратить ввод"
	//M  -  80	//максимальный размер одной строки
	//N  -  10	//максимальное количество строк в массиве

	/*
	const char STOP_STRING = '*';
	const size_t M = 80;
	const size_t N = 10;


//Объявите двухмерный массив с именем cBuffer типа char и
// размерностью N*M

	char cBuffer[N][M];

//Объявите массив (с именем cPointers) указателей на строки
//размерностью N

	char* cPointers[N];

//Цикл ввода строк:
//а) выведите приглашение для ввода
	
	*/
	//std::cout << "please input string";

//б) пока не введена строка STOP_STRING или не заполнен весь массив
	
	std::string st;
	// cin >> char_array[N*M]
	//char z [5];
	//std::cin >> z;

	stop

	//std::cout << "please input string";
	//std::cin >> z;

	stop

	

	{
		//ввод строки в массив cBuffer:



		//если введена строка - признак окончания, то выйти из цикла

		//Присвойте элементу массива cPointers с индексом nIndex
		//указатель на строку с номером nIndex в массиве cBuffer


	}


	//Выдать диагностику о том, что прием строк завершен.



	//Теперь сортируем строки:

	//Цикл сортировки строк по методу "всплывающего пузырька" в
	//порядке возрастания. На каждой итерации - промежуточная печать
	//отсортированных строк

	/*
	*/

	/*
	//Задание 4*. Объявление и использование указателей на многомерные
	// массивы. Проинициализируйте трехмерный массив
	//double dArray[4][3][3] так, как показано на рисунке и напишите фрагмент
	//кода, который меняет местами значения элементов четных
	//и нечетных слоев:
	//	было:			     |--------|
	//  				   / |4  4  4 |
	//					 |--------|	4 |
	//				   / |3  3  3 |	4 |
	//    			 |---------|3 |   |
	//			   / | 2  2  2 |3 | /
	//			  |---------|2 |__|
	//			  | 1  1  1 |2 | /
	//			  | 1  1  1 |__|
	//			  | 1  1  1 | /
	//			  |_________|

	//	стало:			     |--------|
	//  				   / |3  3  3 |
	//					 |--------|	3 |
	//				   / |4  4  4 |	3 |
	//    			 |---------|4 |   |
	//			   / | 1  1  1 |4 | /
	//			  |---------|1 |__|
	//			  | 2  2  2 |1 | /
	//			  | 2  2  2 |__|
	//			  | 2  2  2 | /
	//			  |_________|

	for(int i=0; i<...; ...)
	{
	//Замечание: НЕ НУЖНО МОДИФИЦИРОВАТЬ ВЫРАЖЕНИЯ СПРАВА ОТ ЗНАКА РАВЕНСТВА!!!
	... =  dArray[i];
	... =  dArray[i+1];
	//переставляем местами элементы i-того и i+1-ого слоев


	}
	*/
	
	const size_t x = 4;
	const size_t y = 3;
	const size_t z = 3;
	double dArray[x][y][z];

	for (size_t i = 0; i < x; i++)
	{
		double* dptr = &dArray[i][0][0];
		for (size_t j = 0; j < (y * z); j++, dptr++) *dptr = (i + 1);
	}

	for (size_t i = 0; i < x; i += 2)
	{
		double* lp = &dArray[i][0][0];
		double* rp = &dArray[(i + 1)][0][0];

		for (size_t j = 0; j < (y * z); j++, lp++, rp++)
		{
			double t = *lp;
			*lp = *rp;
			*rp = t;
		}


	}
	

	stop

	///////////////////////////////////////////////////////////////////////////
	//Задание 5а. Объявите двухмерный ВСТРОЕННЫЙ массив элементов типа char.
	//Сформируйте значения элементов массива с помощью генератора случайных
	//чисел таким образом, чтобы в массиве были только символы '*' и '_'


	//В каждой строке "сдвиньте звездочки" в начало строки, например:
	//было - '*' '_' '_' '*' '*' '_' '*' '_' '*' '_'
	//стало: '*' '*' '*' '*' '*' '_' '_' '_' '_' '_'
	//и распечатайте массив по строкам - "постройте распределение"

	{
		const size_t N = 5;
		const size_t M = 10;

		char char_array[N][M];


		char* c = &char_array[0][0];

		size_t n = sizeof(char_array) / sizeof(char_array[0][0]);

		for (size_t i = 0; i < n; i++, c++) *c = get_symbol();

		print_char_array(&char_array[0][0], n, M, WITH_SPACES);

		stop

		size_t rows = N;
		
		size_t els = M;
		
		for (size_t i = 0; i < els; i++)
		{
			bool swaped;
			char* cptr = &char_array[0][i];
			do
			{
				swaped = false;
				for (size_t i = 0; i < (N * M); i += M)
				{
					if ((*(cptr + i) == '*') && (*(cptr + i + M) == '_'))
					{
						*(cptr + i) = '_';
						*(cptr + i + M) = '*';
						swaped = true;
					}

				}


			} while (swaped);
		}

		print_char_array(&char_array[0][0], n, M, WITH_SPACES);

		stop
		
		for (size_t i = 0; i < rows; i++)
		{
			bool swaped;
			char* cptr = &char_array[i][0];
			do
			{
				swaped = false;
				for (size_t i = 0; i < (els - 1); i++)
				{
					if ((*(cptr + i) == '_') && (*(cptr + i + 1) == '*'))
					{
						*(cptr + i) = '*';
						*(cptr + i + 1) = '_';
						swaped = true;
					}

				}


			} while (swaped);
		}
		
		
		

		print_char_array(&char_array[0][0], n, M, WITH_SPACES);



	}
	






// 5б. Модифицируйте предыдущее задание следующим способом:
//После заполнения массива с помощью генератора случайных чисел
//"сдвиньте" звездочки по столбцам вниз и распечатайте полученное
//"распределение"

///////////////////////////////////////////////////////////////
//			Динамическое выделение памяти                    //
///////////////////////////////////////////////////////////////
	//Задание 6. Создайте ДИНАМИЧЕСКИЙ двухмерный массив с размерностями,
	//вычисляемыми в процессе выполнения программы - N*M.
	//Задайте значения элементов помощью генератора случайных чисел.
	//Найдите  сумму элементов.
	//Подсказка 1: для генерации случайных чисел используйте функцию
	//стандартной библиотеки - rand() (<cstdlib>)
	//Подсказка 2: На самом деле те значения, которые создаются генератором случайных
	//чисел являются «псевдослучайными», то есть при двух последовательных запусках
	//приложения Вы получаете две одинаковые последовательности значений.
	//Для того чтобы генерируемые "случайные" значения были разными при каждом 
	//запуске приложения используйте функции стандартной библиотеки srand() (<cstdlib>)
	//и time() (<ctime>).
	//Функция srand() осуществляет «привязку» начала генерации к указанному в качестве параметра значению.
	//Функция time() задает эту точку отсчета, считывая текущее время
	
	//srand( time( 0 ) );
	
	size_t N = 4;
	size_t M = 7;

	int** pp = new int*[N];

	for (size_t i = 0; i < N; i++)
	{
		pp[i] = new int[M];
	}

	srand(time(0));

	for (size_t i = 0; i < N; i++)
	{
		for (size_t j = 0; j < M; j++)
		{
			pp[i][j] = rand();
		}
	}

	std::cout << std::endl;

	for (size_t i = 0; i < N; i++)
	{
		for (size_t j = 0; j < M; j++)
		{
			std::cout << pp[i][j] << " ";
		}
		std::cout << std::endl;
	}

	int sum = 0;
	for (size_t i = 0; i < N; i++)
	{
		for (size_t j = 0; j < M; j++)
		{
			sum += pp[i][j];
		}
	}


	std::cout << std::endl;
	
	std::cout << "sum of elements = " << sum;

	stop


	//Задание 6а. В сформированном массиве отсортируйте каждую строку по
	//убыванию значений. Используйте сортировку "выбором"

	for (size_t i = 0; i < N; i++)
	{
		for (size_t j = 0; j < (M + 1); j++)
		{
			size_t min = j;
			size_t base = j;
			for (size_t z = (j + 1); z < M; z++)
			{
				if (pp[i][min] < pp[i][z])
				{
					min = z;
				}
			}
			int t = pp[i][base];
			pp[i][base] = pp[i][min];
			pp[i][min] = t;
		}
	}

	std::cout << std::endl;

	for (size_t i = 0; i < N; i++)
	{
		for (size_t j = 0; j < M; j++)
		{
			std::cout << pp[i][j] << " ";
		}
		std::cout << std::endl;
	}

	stop

	//Задание 6б. Объявите одномерный массив размерностью N.
	//Сформируйте значение i-ого элемента одномерного массива  
	//равным среднему значению элементов i-ой строки
	//двухмерного массива

	int* p = new int[N];

	
	for (size_t i = 0; i < N; i++)
	{
		int sum = 0;

		for (size_t j = 0; j < M; j++)
		{
			sum += pp[i][j];
		}
		sum /= M;
		p[i] = sum;
		std::cout << std::endl << sum;
	}

	stop

	for (size_t i = 0; i < N; i++)
	{
		delete[] pp[i];
	}
	delete[] pp;
	delete[] p;

	//Подсказка - не забудьте освободить память!




	

/*
	//Задание 7*. Реализуйте задание №3, используя не встроенные,
	//а ДИНАМИЧЕСКИЕ массивы (массив?). Так как строки могут быть разной длины,
	//эффективным решением было бы отводить под каждую строку ровно столько байтов,
	//сколько требуется для ее хранения.
	//При этом необходимые параметры (количество строк
	// сформируйте с помощью потока ввода
	int nStringNumber;


	

  
	

  
	//Цикл ввода строк:

  


	//Цикл сортировки строк по методу "всплывающего пузырька" в
	//порядке возрастания кода первого символа

  
	
	  
		
	//Освобождение занятой памяти:




*/



	return 0;
}